package dev.scx.http.received;

import dev.scx.http.headers.ScxHttpHeaders;
import dev.scx.io.ByteInput;

/// 本接口用于表达:
/// 一次 HTTP message head(头部) 接收已经完成之后, 在协议层面已经成立, 不可回溯的「接收结果事实」.
///
/// ScxHttpReceived 并不是一个 "接收器(Receiver)",
/// 也不表达任何进行中的接收过程, 控制语义或生命周期推进,
/// 而是一个针对「已经被成功接收的 HTTP 消息头(message head)」的只读视图 (immutable view).
///
/// # 1. 为何命名为 ScxHttpReceived
///
/// 选择 ScxHttpReceived, 是为了明确强调:
/// 本接口所表达的是
/// 「HTTP 接收这一协议行为已经发生并终结之后的结果」,
/// 而不是接收过程本身.
///
/// 命名中的 Received 是刻意选择的过去分词, 其含义是:
///
/// - HTTP 接收这一协议动作已经完成
/// - 连接状态不再因本接口而推进
/// - 调用方只能观察既成事实, 而不能影响或回溯过程
///
/// 基于上述语义, 以下命名方案已被系统性考虑并明确排除:
///
/// - HttpReceiver / HttpReader:
///   这些命名暗示接口仍参与接收行为或读取控制,
///   与"已完成的接收结果事实"这一定位不符.
///
/// - HttpInput / HttpInputStream / HttpInputMessage:
///   这些命名将 HTTP 接收结果退化为通用 IO 抽象,
///   混淆了「协议接收完成」与「字节读取」之间的语义边界.
///
/// - HttpMessage / HttpRequest / HttpResponse:
///   这些命名暗示该对象是一个可构造, 可复制的值对象,
///   而 HttpReceived 表达的是一次不可逆的协议结果事实,
///   并非消息值本身.
///
/// - HttpInbound / HttpIncoming / HttpIn:
///   这些命名基于输入 / 输出的形式对称,
///   但 HTTP 接收端与发送端在语义上并不对称,
///   强行对称只会掩盖协议行为的不可逆性.
///
/// - HttpContext / HttpExchange / HttpEnvelope:
///   这些命名模糊了生命周期边界,
///   容易演化为状态或行为的聚合容器,
///   与本接口"最小事实抽象"的设计目标相冲突.
///
/// # 2. 只读事实抽象(No Action Semantics)
///
/// ScxHttpReceived 的所有方法均用于表达已经成立的协议事实:
///
/// - headers()    : 已确定的 HTTP 头信息
/// - bodyLength() : 消息体在协议层面上的实际字节长度(若可确定)
/// - body()       : 消息体的顺序字节读取入口
///
/// 本接口刻意不包含任何动作性语义, 例如:
///
/// - 接收或读取控制(receive / read)
/// - 生命周期推进
/// - 线程, 异步或连接管理
///
/// 任何试图向本接口中引入上述内容的修改,
/// 均意味着抽象层级的错误.
///
/// # 3 . 关于 bodyLength() 的存在理由
///
/// bodyLength() 表达的是:
/// 「该 HTTP 消息体在协议层面上的实际总字节数(如果已知)」,
/// 而不是某一个具体头字段(如 Content-Length).
///
/// 该方法必须作为独立抽象存在, 原因如下:
///
/// - 1. bodyLength 并不是 body 的属性
///    body() 仅表达顺序字节的读取能力,
///    而长度信息属于对整个消息体的整体事实判断,
///    二者在语义上并不等价.
///
/// - 2. HTTP 允许 body 存在但总长度不可提前确定
///    (如 chunked transfer, 流式传输, 协议升级前等场景),
///    因此 bodyLength() 需要显式区分以下语义:
///
///    - null : 当前无法确定总长度
///    - 0    : body 存在但为空
///    - 大于 0 : 已知的总字节数
///
/// - 3. 将 bodyLength 作为独立方法,
///    可以在不读取 body 的前提下获取长度事实,
///    避免将 "读取行为" 与 "事实判断" 耦合.
///
/// # 4, 关于"接收完成"与 body 读取失败的关系
///
/// "接收完成的事实"并不意味着 body 的读取一定不会失败.
///
/// ScxHttpReceived 表达的是 HTTP message head(头部) 在协议层面已经成立的接收结果,
/// 而 body() 返回的 ByteInput 仍然是对底层 IO 载体的一次性访问,
/// 其读取过程可能因资源限制, 连接中断或实现策略而失败.
///
/// 这类失败属于「事实载体的可用性问题」,
/// 并不否定该 HTTP message head(头部) 已经被成功接收这一协议事实.
///
/// # 5. 关于不可再削减性(Design Closure)
///
/// 本接口是对 HTTP 接收端「最小语义完备抽象」的最终收敛结果.
///
/// 在既定前提不变的情况下:
///
/// - 删除任何一个方法, 都会导致协议事实表达能力下降
/// - 合并方法, 必然引入语义混淆
/// - 增加方法, 则不可避免地引入动作语义或生命周期歧义
///
/// 因此, 对本接口的结构性修改,
/// 通常不会带来新的设计信息,
/// 而只是在重复已经被验证过的退化路径.
///
/// 若需要缓存, 解码, 反序列化或可回溯读取等能力,
/// 应通过装饰器或更高层抽象完成,
/// 而不应修改本接口本身.
///
/// 换句话说:
/// 如果你认为可以对该接口进行任何 "优化" "重构" 或 "重命名",
/// 那么你大概率是在重新引入一个已经被否定的设计方向.
///
/// @author scx567888
/// @version 0.0.1
public interface ScxHttpReceived {

    /// 一个 "只读" 的头.
    ScxHttpHeaders headers();

    /// body 的实际字节长度 (如果已知).
    ///
    /// - null : 未知的 body 总字节长度.
    /// - 大于等于 0 : 已知的 body 总字节长度.
    default Long bodyLength() {
        return null;
    }

    /// 返回消息体的顺序字节输入.
    ///
    /// 该输入表示该消息体的顺序读取入口,
    /// 通常是一次性的, 不可回溯的.
    /// (如需多次读取, 可通过装饰器引入缓存策略.)
    ByteInput body();

}
